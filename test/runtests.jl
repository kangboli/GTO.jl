using GTO
using Test
using LinearAlgebra

# Most integrals are tested against the result from pyscf, which gets its integrals from libcint.


@testset "Gaussian product evaluation." begin
    @test hermite(3, 3) == 8 * 3^3 - 12 * 3

    c1 = CartesianGaussian(0, 0, 0, 1, [0, 0, 0])
    c2 = CartesianGaussian(0, 0, 0, 1, [1, 0, 0])
    c3 = gaussian_product(c1, c2)
    p = [1, 1, 0]
    @test isapprox(evaluate(c1, p) * evaluate(c2, p), evaluate(c3, p), atol=1e-7)

    c1 = CartesianGaussian(1, 0, 0, 1, [0, 0, 0])
    c2 = CartesianGaussian(0, 0, 0, 1, [1, 0, 0])
    c3 = gaussian_product(c1, c2)
    p = [0.5, 1, 0]

    @test isapprox(evaluate(c1, p) * evaluate(c2, p), evaluate(c3, p), atol=1e-7)
end


b = load_basis("sto-3g.1.json")

@testset "single Helium one electron integral" begin
    a_1 = Atom(2, [0, 0, 0])
    shells = make_gaussians(b, a_1)
    basis = vcat(get_basis.(shells)...)
    g = first(basis)
    @test isapprox(g' * g, 1.0, atol=1e-7)
    @test isapprox(g' * VNuc([a_1]) * g, -3.3435116, atol=1e-6)
    # @test isapprox(kinetic_integral(g, g), 1.41176318, atol=1e-6)
    @test isapprox(g' * ∇² * g, 1.41176318, atol=1e-6)
end

@testset "single Helium two electrons integral" begin
    a_1 = Atom(2, [0, 0, 0])
    shells = make_gaussians(b, a_1)
    basis = vcat(get_basis.(shells)...)
    g = first(basis)
    @test isapprox((g * g | g * g), 1.05571294, atol=1e-6)
end


@testset "single Carbon one electron integral" begin
    a_1 = Atom(6, [0, 0, 0])
    shells = make_gaussians(b, a_1)
    basis = vcat(get_basis.(shells)...)
    S = [b_1' * b_2 for b_1 in basis, b_2 in basis]
    @test all(i -> isapprox(S[i, i], 1, atol=1e-7), 1:length(basis))
    @test isapprox(S[1, 2], 0.248362, atol=1e-4)

    V = [r' * VNuc([a_1]) * s for r in basis, s in basis]
    V_pyscf = [
        -33.65274108 -4.19222872 0.0 0.0 0.0
        -4.19222872 -5.18976649 0.0 0.0 0.0
        0.0 0.0 -5.14822071 0.0 0.0
        0.0 0.0 0.0 -5.14822071 0.0
        0.0 0.0 0.0 0.0 -5.14822071]

    @test isapprox(V, V_pyscf, atol=1e-6)

    K = [kinetic_integral(r, s) for r in basis, s in basis]
    K_pyscf = [
        15.89112169 -0.08589001 0.0 0.0 0.0
        -0.08589001 0.47224997 0.0 0.0 0.0
        0.0 0.0 1.47772808 0.0 0.0
        0.0 0.0 0.0 1.47772808 0.0
        0.0 0.0 0.0 0.0 1.47772808]

    @test isapprox(K, K_pyscf, atol=1e-6)
end

@testset "single Carbon two electrons integral" begin
    a_1 = Atom(6, [0, 0, 0])
    shells = make_gaussians(b, a_1)
    basis = vcat(get_basis.(shells)...)

    ee = [two_electron_integral(p * q, r * s) for p in basis, q in basis, r in basis, s in basis]

    @test isapprox(ee[:, :, 2, 4], [
            0.0 0.0 0.0 0.03085775 0.0
            0.0 0.0 0.0 0.13799628 0.0
            0.0 0.0 0.0 0.0 0.0
            0.03085775 0.13799628 0.0 0.0 0.0
            0.0 0.0 0.0 0.0 0.0], atol=1e-6)

    @test isapprox(ee[:, :, 3, 3], [
            0.85243608 0.20533508 0.0 0.0 0.0
            0.20533508 0.62456837 0.0 0.0 0.0
            0.0 0.0 0.67283272 0.0 0.0
            0.0 0.0 0.0 0.60029544 0.0
            0.0 0.0 0.0 0.0 0.60029544], atol=1e-6)

    @test isapprox(ee[:, :, 1, 5], [0.0 0.0 0.0 0.0 0.02029646
            0.0 0.0 0.0 0.0 0.03085775
            0.0 0.0 0.0 0.0 0.0
            0.0 0.0 0.0 0.0 0.0
            0.02029646 0.03085775 0.0 0.0 0.0], atol=1e-6)
end


@testset "two Carbon one electron integral" begin
    a_1 = Atom(6, [0, 0, 0])
    a_2 = Atom(6, [2 / BOHR_TO_ANGSTROM, 0, 0])
    shells = make_gaussians(b, a_1, a_2)
    basis = vcat(get_basis.(shells)...)
    S = [b_1' * b_2 for b_1 in basis, b_2 in basis]
    S_pyscf = [
        1.00000000e+00 2.48362390e-01 0.00000000e+00 0.00000000e+00 0.00000000e+00 2.21364612e-12 7.44706669e-03 -1.44147287e-02 0.00000000e+00 0.00000000e+00
        2.48362390e-01 1.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 7.44706669e-03 1.39396206e-01 -1.83166444e-01 0.00000000e+00 0.00000000e+00
        0.00000000e+00 0.00000000e+00 1.00000000e+00 0.00000000e+00 0.00000000e+00 1.44147287e-02 1.83166444e-01 -2.12324943e-01 0.00000000e+00 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 1.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -0.00000000e+00 6.52518609e-02 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 1.00000000e+00 0.00000000e+00 0.00000000e+00 -0.00000000e+00 0.00000000e+00 6.52518609e-02
        2.21364612e-12 7.44706669e-03 1.44147287e-02 0.00000000e+00 0.00000000e+00 1.00000000e+00 2.48362390e-01 -4.53751669e-17 0.00000000e+00 0.00000000e+00
        7.44706669e-03 1.39396206e-01 1.83166444e-01 0.00000000e+00 0.00000000e+00 2.48362390e-01 1.00000000e+00 -3.01795980e-16 0.00000000e+00 0.00000000e+00
        -1.44147287e-02 -1.83166444e-01 -2.12324943e-01 -0.00000000e+00 -0.00000000e+00 -4.53751669e-17 -3.01795980e-16 1.00000000e+00 0.00000000e+00 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 6.52518609e-02 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 1.00000000e+00 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 6.52518609e-02 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 1.00000000e+00]
    @test isapprox(S, S_pyscf, atol=1e-7)
    V = [b_1' * VNuc(a_1, a_2) * b_2 for b_1 in basis, b_2 in basis]

    V_pyscf = [-3.52402727e+01 -4.58651187e+00 -3.01823789e-02 0.00000000e+00 0.00000000e+00 -1.40569394e-11 -1.37360319e-01 2.69705937e-01 0.00000000e+00 0.00000000e+00
        -4.58651187e+00 -6.77701348e+00 -3.51655057e-01 0.00000000e+00 0.00000000e+00 -1.37360319e-01 -8.54647455e-01 1.13623464e+00 0.00000000e+00 0.00000000e+00
        -3.01823789e-02 -3.51655057e-01 -6.84724552e+00 0.00000000e+00 0.00000000e+00 -2.69705937e-01 -1.13623464e+00 1.31605013e+00 0.00000000e+00 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 -6.67926383e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -3.41610806e-01 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -6.67926383e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -3.41610806e-01
        -1.40569394e-11 -1.37360319e-01 -2.69705937e-01 0.00000000e+00 0.00000000e+00 -3.52402727e+01 -4.58651187e+00 3.01823789e-02 0.00000000e+00 0.00000000e+00
        -1.37360319e-01 -8.54647455e-01 -1.13623464e+00 0.00000000e+00 0.00000000e+00 -4.58651187e+00 -6.77701348e+00 3.51655057e-01 0.00000000e+00 0.00000000e+00
        2.69705937e-01 1.13623464e+00 1.31605013e+00 0.00000000e+00 0.00000000e+00 3.01823789e-02 3.51655057e-01 -6.84724552e+00 0.00000000e+00 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 -3.41610806e-01 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -6.67926383e+00 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -3.41610806e-01 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -6.67926383e+00]

    @test isapprox(V, V_pyscf, atol=1e-6)

    # K = [kinetic_integral(r, s) for r in basis, s in basis]
    K = [r' * ∇² * s for r in basis, s in basis]

    K_pyscf = [1.58911217e+01 -8.58900137e-02 0.00000000e+00 0.00000000e+00 0.00000000e+00 -1.85343150e-10 -5.11807831e-03 5.31215290e-03 0.00000000e+00 0.00000000e+00
        -8.58900137e-02 4.72249973e-01 0.00000000e+00 0.00000000e+00 0.00000000e+00 -5.11807831e-03 -1.52318537e-02 -1.39734348e-02 0.00000000e+00 0.00000000e+00
        0.00000000e+00 0.00000000e+00 1.47772808e+00 0.00000000e+00 0.00000000e+00 -5.31215290e-03 1.39734348e-02 -6.57850698e-02 0.00000000e+00 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 1.47772808e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 2.40327896e-03 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 1.47772808e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 2.40327896e-03
        -1.85343150e-10 -5.11807831e-03 -5.31215290e-03 0.00000000e+00 0.00000000e+00 1.58911217e+01 -8.58900137e-02 -1.05044841e-15 0.00000000e+00 0.00000000e+00
        -5.11807831e-03 -1.52318537e-02 1.39734348e-02 0.00000000e+00 0.00000000e+00 -8.58900137e-02 4.72249973e-01 -2.53111336e-16 0.00000000e+00 0.00000000e+00
        5.31215290e-03 -1.39734348e-02 -6.57850698e-02 0.00000000e+00 0.00000000e+00 4.36305943e-15 -7.06448324e-17 1.47772808e+00 0.00000000e+00 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 2.40327896e-03 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 1.47772808e+00 0.00000000e+00
        0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 2.40327896e-03 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 1.47772808e+00]


    @test isapprox(K, K_pyscf, atol=1e-6)

end

@testset "two Carbon two electrons integral" begin
    a_1 = Atom(6, [0, 0, 0])
    a_2 = Atom(6, [2 / BOHR_TO_ANGSTROM, 0, 0])
    shells = make_gaussians(b, a_1, a_2)
    basis = vcat(get_basis.(shells)...)
    ee = [two_electron_integral(p * q, r * s) for p in basis, q in basis, r in basis, s in basis]
    @test isapprox(ee[:, :, 2, 8], [
            -1.06448086e-01 -2.60381307e-02 -2.69030571e-03 0.00000000e+00 0.00000000e+00 -3.33428598e-13 -8.29061965e-04 1.59215969e-03 0.00000000e+00 0.00000000e+00
            -2.60381307e-02 -9.07528556e-02 -2.05205355e-02 0.00000000e+00 0.00000000e+00 -6.62730768e-04 -1.47207948e-02 2.05039510e-02 0.00000000e+00 0.00000000e+00
            -2.69030571e-03 -2.05205355e-02 -9.58051801e-02 0.00000000e+00 0.00000000e+00 -1.26830154e-03 -1.98585064e-02 2.57210451e-02 0.00000000e+00 0.00000000e+00
            0.00000000e+00 0.00000000e+00 0.00000000e+00 -8.81772359e-02 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -5.95613347e-03 0.00000000e+00
            0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -8.81772359e-02 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -5.95613347e-03
            -3.33428598e-13 -6.62730768e-04 -1.26830154e-03 0.00000000e+00 0.00000000e+00 -8.22548345e-02 -2.03454800e-02 2.84014326e-03 0.00000000e+00 0.00000000e+00
            -8.29061965e-04 -1.47207948e-02 -1.98585064e-02 0.00000000e+00 0.00000000e+00 -2.03454800e-02 -7.58669832e-02 2.19371417e-02 0.00000000e+00 0.00000000e+00
            1.59215969e-03 2.05039510e-02 2.57210451e-02 0.00000000e+00 0.00000000e+00 2.84014326e-03 2.19371417e-02 -8.24325997e-02 0.00000000e+00 0.00000000e+00
            0.00000000e+00 0.00000000e+00 0.00000000e+00 -5.95613347e-03 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -7.25399010e-02 0.00000000e+00
            0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -5.95613347e-03 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -7.25399010e-02], atol=1e-6)

    @test isapprox(ee[:, :, 10, 10], [
            2.55173787e-01 6.33754108e-02 4.49385249e-03 0.00000000e+00 0.00000000e+00 1.01294193e-12 1.98573956e-03 -3.81991702e-03 0.00000000e+00 0.00000000e+00
            6.33754108e-02 2.54898512e-01 5.20115887e-02 0.00000000e+00 0.00000000e+00 6.10347949e-03 6.04936596e-02 -7.25399010e-02 0.00000000e+00 0.00000000e+00
            4.49385249e-03 5.20115887e-02 2.69251314e-01 0.00000000e+00 0.00000000e+00 1.18461398e-02 8.81772359e-02 -9.44073112e-02 0.00000000e+00 0.00000000e+00
            0.00000000e+00 0.00000000e+00 0.00000000e+00 2.46730972e-01 0.00000000e+00 0.00000000e+00 0.00000000e+00 -0.00000000e+00 2.52320248e-02 0.00000000e+00
            0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 2.48571472e-01 0.00000000e+00 0.00000000e+00 -0.00000000e+00 0.00000000e+00 2.69316246e-02
            1.01294193e-12 6.10347949e-03 1.18461398e-02 0.00000000e+00 0.00000000e+00 8.52436078e-01 2.05335079e-01 -4.90407715e-17 0.00000000e+00 0.00000000e+00
            1.98573956e-03 6.04936596e-02 8.81772359e-02 0.00000000e+00 0.00000000e+00 2.05335079e-01 6.24568372e-01 -1.88739702e-16 0.00000000e+00 0.00000000e+00
            -3.81991702e-03 -7.25399010e-02 -9.44073112e-02 -0.00000000e+00 -0.00000000e+00 -4.90407715e-17 -1.88739702e-16 6.00295438e-01 0.00000000e+00 0.00000000e+00
            0.00000000e+00 0.00000000e+00 0.00000000e+00 2.52320248e-02 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 6.00295438e-01 0.00000000e+00
            0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 2.69316246e-02 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 6.72832721e-01], atol=1e-6)
end


# a_2 = Atom(2, [2 / BOHR_TO_ANGSTROM,0,0])
# # a_2 = cache!(c, Atom(2, [2,0,0]))

# shells = vcat(map(a->make_gaussians(b, a, c), [a_1, a_2])...)
# shells = vcat(map(a->make_gaussians(b, a, c), [a_1])...)
# basis = vcat(get_basis.(shells)...)

# # basis = [contract(
# #     [0.7, 0.7],
# #     [CartesianGaussian(0,0,0, 10, [0,0,0]),
# #      CartesianGaussian(0,0,0, 5, [0,0,0])], true)]
# # basis = [contract([0.1543289672914523, 0.5353281422703502, 0.4446345421753733], 
# #          [CartesianGaussian(0, 0, 0, 22.72061597744982, [0.0, 0.0, 0.0], 1), 
# #          CartesianGaussian(0, 0, 0, 4.138588561981291, [0.0, 0.0, 0.0], 2), 
# #          CartesianGaussian(0, 0, 0, 1.1200635768638472, [0.0, 0.0, 0.0], 3)])]

# [overlap_integral(gaussian_product(b_1, b_2)) for b_1 in basis, b_2 in basis]
# [nuclear_potential(gaussian_product(b_1, b_2), a_1) for b_1 in basis, b_2 in basis]
#  + [nuclear_potential(gaussian_product(b_1, b_2), coordinates(a_2)) for b_1 in basis, b_2 in basis]

# overlap_integral(gaussian_product(basis[1],  basis[1]))
# nuclear_potential(gaussian_product(basis[1],  basis[1]), coordinates(a_1))

# overlap_integral(gaussian_product( basis[1],  basis[1]))


# c = Cache()
# a_1 = cache!(c, Atom(8, [0,0,0]))
# a_2 = cache!(c, Atom(8, [1 / BOHR_TO_ANGSTROM, 0, 0]))
# # a_2 = cache!(c, Atom(2, [2,0,0]))

# # shells = vcat(map(a->make_gaussians(b, a, c), [a_1, a_2])...)
# shells = vcat(map(a->make_gaussians(b, a, c), [a_1])...)
# basis = vcat(get_basis.(shells)...)

# [overlap_integral(gaussian_product(b_1, b_2)) for b_1 in basis, b_2 in basis]
# [nuclear_potential(gaussian_product(b_1, b_2), a_1) for b_1 in basis, b_2 in basis] +
# [nuclear_potential(gaussian_product(b_1, b_2), a_2) for b_1 in basis, b_2 in basis]

# overlap_integral(gaussian_product(basis[1],  basis[1]))
# nuclear_potential(gaussian_product(basis[1],  basis[1]), a_1)
# overlap_integral(gaussian_product(basis[3],  basis[3]))
# nuclear_potential(gaussian_product(basis[3],  basis[3]), a_1)
# nuclear_potential(gaussian_product(basis[3],  basis[3]), a_2)


# overlap_integral(gaussian_product( basis[1],  basis[1])


# gaussian_product(basis[3],  basis[3])

# # c = Cache()
# # a_1 = cache!(c, Atom(8, [0,0,0]))
# # a_2 = cache!(c, Atom(8, [20/BOHR_TO_ANGSTROM,0,0]))

# # basis = [
# #     # CartesianGaussian(0,0,0, 1, [0,0,0]),
# #     #      CartesianGaussian(0,0,0, 3, [0,0,0]),
# #          CartesianGaussian(1,0,0, 3, [0,0,0]),
# #          CartesianGaussian(0,1,0, 3, [0,0,0]),
# #          CartesianGaussian(0,0,1, 3, [0,0,0])
# #          ];
# # # [overlap_integral(gaussian_product(b_1, b_2)) for b_1 in basis, b_2 in basis]
# # [nuclear_potential(gaussian_product(b_1, b_2), a_1) for b_1 in basis, b_2 in basis] 

# # [evaluate(b, [1/BOHR_TO_ANGSTROM, 0, 0]) for b in basis]